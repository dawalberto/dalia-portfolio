---
export interface Props {
  defaultImg: ImageMetadata
  hoverImg: ImageMetadata
  alt: string
  class?: string
  title?: string
  description?: string
  date?: string
  href?: string
}

const { defaultImg, hoverImg, alt, class: className = "" } = Astro.props

const uniqueId = `illustration-${Math.random().toString(36).substr(2, 9)}`
---

<div class={className} data-illustration-id={uniqueId}>
  <div class="custom-cursor"></div>
  <div class="showcase-item">
    <div class="loading">Cargando...</div>
    <canvas class="image-canvas"></canvas>
  </div>
</div>

<style>
  [data-illustration-id] {
    position: relative;
    background-color: #000;
    overflow: hidden;
    cursor: none;
  }

  .showcase-item {
    position: relative;
    width: 100%;
    height: 100%;
    display: block;
  }

  .image-canvas {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .custom-cursor {
    position: fixed;
    width: 20px;
    height: 20px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    pointer-events: none;
    z-index: 1000;
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  .custom-cursor.active {
    opacity: 1;
  }

  .loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 1.2rem;
    z-index: 10;
  }
</style>

<script define:vars={{ defaultImg, hoverImg, alt, uniqueId }}>
  class ImageRevealEffect {
    constructor(defaultImgSrc, hoverImgSrc, containerId) {
      this.container = document.querySelector(`[data-illustration-id="${containerId}"]`)
      if (!this.container) {
        console.error(`Container with id ${containerId} not found`)
        return
      }

      this.canvas = this.container.querySelector(".image-canvas")
      this.ctx = this.canvas.getContext("2d")
      this.showcaseItem = this.container.querySelector(".showcase-item")
      this.cursor = this.container.querySelector(".custom-cursor")
      this.loading = this.container.querySelector(".loading")

      this.mouse = { x: 0, y: 0 }
      this.targetMouse = { x: 0, y: 0 }
      this.isHovering = false
      this.revealRadius = 0
      this.targetRevealRadius = 0
      this.maxRevealRadius = 100
      this.imagesLoaded = 0

      this.time = 0
      this.wavePoints = []
      this.numWaves = 16

      for (let i = 0; i < this.numWaves; i++) {
        this.wavePoints.push({
          angle: (i / this.numWaves) * Math.PI * 2,
          offset: Math.random() * Math.PI * 2,
          speed: 0.8 + Math.random() * 1.2,
          amplitude: 25 + Math.random() * 35,
          frequency1: 0.8 + Math.random() * 0.4,
          frequency2: 1.2 + Math.random() * 0.6,
          frequency3: 0.6 + Math.random() * 0.3,
        })
      }

      this.defaultImgSrc = defaultImgSrc
      this.hoverImgSrc = hoverImgSrc

      this.init()
    }

    init() {
      this.loadImages()
    }

    setupCanvas() {
      // Usar ResizeObserver para ajustar el canvas al tamaÃ±o real del contenedor
      const resizeCanvas = () => {
        const rect = this.container.getBoundingClientRect()
        const dpr = window.devicePixelRatio || 1

        this.canvas.width = rect.width * dpr
        this.canvas.height = rect.height * dpr

        this.ctx.scale(dpr, dpr)

        this.canvas.style.width = rect.width + "px"
        this.canvas.style.height = rect.height + "px"

        if (this.imagesLoaded === 2) {
          this.render()
        }
      }

      resizeCanvas()

      const resizeObserver = new ResizeObserver(resizeCanvas)
      resizeObserver.observe(this.container)

      this.setupEventListeners()
      this.animate()
    }

    loadImages() {
      this.baseImage = new Image()
      this.hoverImage = new Image()
      this.loadedCount = 0

      const checkComplete = () => {
        this.loadedCount++
        if (this.loadedCount === 2) {
          this.onImageLoad()
        }
      }

      const handleError = (imageName, e) => {
        console.error(`${imageName} image failed to load:`, e)
      }

      this.baseImage.addEventListener("load", checkComplete)
      this.hoverImage.addEventListener("load", checkComplete)

      this.baseImage.addEventListener("error", (e) => handleError("default image", e))
      this.hoverImage.addEventListener("error", (e) => handleError("hover image", e))

      this.baseImage.src = this.defaultImgSrc
      this.hoverImage.src = this.hoverImgSrc
    }

    onImageLoad() {
      this.imagesLoaded = 2
      this.loading.style.display = "none"
      this.setupCanvas()
    }

    setupEventListeners() {
      document.addEventListener("mousemove", (e) => {
        this.targetMouse.x = e.clientX
        this.targetMouse.y = e.clientY

        const rect = this.canvas.getBoundingClientRect()
        this.mouseOnCanvas = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        }
      })

      this.showcaseItem.addEventListener("mouseenter", () => {
        this.isHovering = true
        this.targetRevealRadius = this.maxRevealRadius
        this.cursor.classList.add("active")
      })

      this.showcaseItem.addEventListener("mouseleave", () => {
        this.isHovering = false
        this.targetRevealRadius = 0
        this.cursor.classList.remove("active")
      })

      this.showcaseItem.addEventListener("click", (e) => {
        if (this.showcaseItem.getAttribute("href") === "#") {
          e.preventDefault()
        }
        const rect = this.canvas.getBoundingClientRect()
        this.targetRevealRadius = Math.max(rect.width, rect.height)
        setTimeout(() => {
          this.targetRevealRadius = this.isHovering ? this.maxRevealRadius : 0
        }, 500)
      })
    }

    animate() {
      this.time += 0.016

      this.mouse.x += (this.targetMouse.x - this.mouse.x) * 0.1
      this.mouse.y += (this.targetMouse.y - this.mouse.y) * 0.1

      this.cursor.style.left = this.mouse.x + "px"
      this.cursor.style.top = this.mouse.y + "px"

      this.revealRadius += (this.targetRevealRadius - this.revealRadius) * 0.08

      if (this.imagesLoaded === 2) {
        this.render()
      }

      requestAnimationFrame(() => this.animate())
    }

    createLavaPath(centerX, centerY, baseRadius) {
      this.ctx.beginPath()
      const points = []

      for (let i = 0; i < this.numWaves; i++) {
        const wave = this.wavePoints[i]
        const wave1 =
          Math.sin(this.time * wave.speed * wave.frequency1 + wave.offset) * wave.amplitude
        const wave2 =
          Math.cos(this.time * wave.speed * wave.frequency2 + wave.offset + 1) *
          (wave.amplitude * 0.8)
        const wave3 =
          Math.sin(this.time * wave.speed * wave.frequency3 + wave.offset + 2) *
          (wave.amplitude * 0.6)
        const wave4 =
          Math.cos(this.time * wave.speed * 0.5 + wave.offset + 3) * (wave.amplitude * 0.4)

        const totalWave = wave1 + wave2 + wave3 + wave4
        const radius = Math.max(10, baseRadius + totalWave)

        const x = centerX + Math.cos(wave.angle) * radius
        const y = centerY + Math.sin(wave.angle) * radius

        points.push({ x, y })
      }

      this.ctx.moveTo(points[0].x, points[0].y)

      for (let i = 0; i < points.length; i++) {
        const current = points[i]
        const next = points[(i + 1) % points.length]
        const controlX = (current.x + next.x) / 2
        const controlY = (current.y + next.y) / 2
        this.ctx.quadraticCurveTo(current.x, current.y, controlX, controlY)
      }

      this.ctx.closePath()
    }

    render() {
      const rect = this.canvas.getBoundingClientRect()
      this.ctx.clearRect(0, 0, rect.width, rect.height)

      const drawCoverImage = (img) => {
        const canvasRatio = rect.width / rect.height
        const imgRatio = img.width / img.height

        let drawWidth, drawHeight, offsetX, offsetY

        if (canvasRatio > imgRatio) {
          drawWidth = rect.width
          drawHeight = rect.width / imgRatio
          offsetX = 0
          offsetY = (rect.height - drawHeight) / 2
        } else {
          drawHeight = rect.height
          drawWidth = rect.height * imgRatio
          offsetX = (rect.width - drawWidth) / 2
          offsetY = 0
        }

        this.ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight)
      }

      drawCoverImage(this.baseImage)

      if (this.revealRadius > 1 && this.mouseOnCanvas) {
        this.ctx.save()
        this.createLavaPath(this.mouseOnCanvas.x, this.mouseOnCanvas.y, this.revealRadius)
        this.ctx.clip()
        drawCoverImage(this.hoverImage)
        this.ctx.restore()

        this.ctx.save()
        this.createLavaPath(this.mouseOnCanvas.x, this.mouseOnCanvas.y, this.revealRadius)
        this.ctx.strokeStyle = "rgba(255, 255, 255, 0.4)"
        this.ctx.lineWidth = 2
        this.ctx.shadowColor = "rgba(255, 255, 255, 0.6)"
        this.ctx.shadowBlur = 8
        this.ctx.stroke()
        this.ctx.restore()
      }
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    new ImageRevealEffect(defaultImg.src, hoverImg.src, uniqueId)
  })
</script>
